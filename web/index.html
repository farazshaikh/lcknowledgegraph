<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Graph Visualization</title>
    <!-- Load Cytoscape first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.23.0/cytoscape.min.js"></script>
    <!-- Load Dagre separately -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
    <!-- Load Cytoscape-Dagre extension -->
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            padding: 10px 20px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
        }
        #cy {
            flex-grow: 1;
            width: 100%;
            border: 1px solid #ccc;
        }
        .controls {
            padding: 10px;
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-label {
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }
        #search {
            padding: 8px;
            width: 300px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #layout-select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        /* Autocomplete styles */
        .autocomplete-container {
            position: relative;
            display: inline-block;
        }
        .autocomplete-items {
            position: absolute;
            border: 1px solid #ddd;
            border-top: none;
            z-index: 99;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background-color: white;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .autocomplete-items div {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f5f5f5;
        }
        .autocomplete-items div:last-child {
            border-bottom: none;
        }
        .autocomplete-items div:hover {
            background-color: #e9e9e9;
        }
        .autocomplete-active {
            background-color: #4CAF50 !important;
            color: white;
        }
        .nav-links {
            margin-top: 10px;
        }
        .nav-links a {
            color: #3498db;
            text-decoration: none;
            font-weight: bold;
        }
        .nav-links a:hover {
            text-decoration: underline;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .highlight-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }
        .highlight-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        .highlight-options input[type="radio"] {
            margin: 0;
        }
        /* Different highlight classes */
        .highlighted {
            background-color: #ff7f0e !important;
            line-color: #ff7f0e !important;
            target-arrow-color: #ff7f0e !important;
        }
        .reachable {
            background-color: #2ca02c !important;
            line-color: #2ca02c !important;
            target-arrow-color: #2ca02c !important;
        }
        .prerequisite {
            background-color: #d62728 !important;
            line-color: #d62728 !important;
            target-arrow-color: #d62728 !important;
        }
        .faded {
            opacity: 0.25;
        }
    </style>
</head>
<body>
    <div id="header">
        <div class="header-content">
            <div class="header-column">
                <div class="header-title">
                    <h1>Knowledge Graph</h1>
                </div>
                <div class="nav-links">
                    <a href="/">Home</a>
                    <a href="/metrics">Metrics</a>
                </div>
            </div>

            <div class="header-column">
                <div style="display: flex; gap: 20px; justify-content: flex-start;">
                    <div class="control-group">
                        <label for="problem-search" class="control-label">Problem:</label>
                        <div class="autocomplete-container">
                            <input type="text" id="problem-search" placeholder="Type to search problems (LC_)...">
                            <div id="problem-autocomplete-list" class="autocomplete-items" style="display: none;"></div>
                        </div>
                    </div>


                    <div class="control-group">
                        <label for="search" class="control-label">Concept:</label>
                        <div class="autocomplete-container">
                            <input type="text" id="search" placeholder="Type to search concepts...">
                            <div id="autocomplete-list" class="autocomplete-items" style="display: none;"></div>
                        </div>
                    </div>


                    <div class="control-group">
                        <label for="layout-select" class="control-label">Layout:</label>
                        <select id="layout-select">
                            <option value="circle">Circle</option>
                            <option value="grid">Grid</option>
                            <option value="concentric">Concentric</option>
                            <option value="breadthfirst">Breadth First</option>
                            <option value="cose">Force-Directed (CoSE)</option>
                            <option value="random">Random</option>
                            <option value="dagre">Dagre (Hierarchical)</option>
                        </select>
                    </div>
                </div>

                <div class="highlight-options">
                    <span class="control-label">Highlight:</span>
                    <label>
                        <input type="radio" name="highlight-mode" value="reachable" checked>
                        Reachable
                    </label>
                    <label>
                        <input type="radio" name="highlight-mode" value="direct">
                        Direct
                    </label>
                    <label>
                        <input type="radio" name="highlight-mode" value="prerequisites">
                        Prerequisites
                    </label>
                </div>
            </div>
            
            <div class="header-column">
                <div class="theme-toggle">
                    <label for="dark-mode-toggle" class="control-label">Dark Mode</label>
                    <label class="switch">
                        <input type="checkbox" id="dark-mode-toggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                <button id="reset">Reset View</button>
            </div>
        </div>
    </div>
    <style>
        #header {
            padding: 10px 15px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-title {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .header-title h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .nav-links {
            font-size: 0.9rem;
        }
        .highlight-options {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-top: 0;
        }
        .highlight-options label {
            font-size: 0.85rem;
        }
    </style>

    <div id="cy"></div>

    <script>
        // Register the Dagre extension with Cytoscape
        if (typeof cytoscape !== 'undefined' && typeof cytoscapeDagre !== 'undefined') {
            try {
                cytoscapeDagre(cytoscape); // This is the correct way to register the extension
                console.log('Registered Dagre extension with Cytoscape');
            } catch (error) {
                console.error('Failed to register Dagre extension:', error);
            }
        } else {
            console.error('Cytoscape or cytoscapeDagre is not loaded');
        }

        window.onload = function() {
            console.log('Page loaded, fetching graph data...');

            // Dark mode toggle functionality
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const body = document.body;
            
            // Add dark mode styles to document head
            const darkModeStyles = document.createElement('style');
            darkModeStyles.textContent = `
                body.dark-mode {
                    background-color: #222;
                    color: #f5f5f5;
                }
                body.dark-mode #header {
                    background-color: #333;
                    border-color: #444;
                }
                body.dark-mode .control-label {
                    color: #f5f5f5;
                }
                body.dark-mode #search,
                body.dark-mode #problem-search,
                body.dark-mode #layout-select {
                    background-color: #444;
                    color: #f5f5f5;
                    border-color: #555;
                }
                body.dark-mode #autocomplete-list div,
                body.dark-mode #problem-autocomplete-list div {
                    background-color: #444;
                    color: #f5f5f5;
                    border-color: #555;
                }
                body.dark-mode #autocomplete-list div:hover,
                body.dark-mode #problem-autocomplete-list div:hover,
                body.dark-mode #autocomplete-list .autocomplete-active,
                body.dark-mode #problem-autocomplete-list .autocomplete-active {
                    background-color: #555;
                }
                body.dark-mode button {
                    background-color: #444;
                    color: #f5f5f5;
                    border-color: #555;
                }
                body.dark-mode button:hover {
                    background-color: #555;
                }
            `;
            document.head.appendChild(darkModeStyles);
            
            // Check for saved preference
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            
            // Apply saved preference
            if (isDarkMode) {
                body.classList.add('dark-mode');
                darkModeToggle.checked = true;
            }
            
            // Toggle dark mode when checkbox is clicked
            darkModeToggle.addEventListener('change', function() {
                if (this.checked) {
                    body.classList.add('dark-mode');
                    localStorage.setItem('darkMode', 'true');
                } else {
                    body.classList.remove('dark-mode');
                    localStorage.setItem('darkMode', 'false');
                }
                
                // Update graph styles if it's already loaded
                if (window.cy) {
                    updateGraphStyles();
                }
            });
            
            // Function to update graph styles based on dark mode
            function updateGraphStyles() {
                const isDark = body.classList.contains('dark-mode');
                
                // Update node and edge styles based on dark mode
                cy.style()
                    .selector('node')
                    .style({
                        'background-color': '#6FB1FC',
                        'text-outline-color': isDark ? '#333' : '#fff',
                        'color': isDark ? '#fff' : '#000'
                    })
                    .selector('edge')
                    .style({
                        'line-color': isDark ? '#888' : '#ccc',
                        'target-arrow-color': isDark ? '#888' : '#ccc'
                    })
                    .update();
            }

            fetch('./graph.json')
                .then(response => {
                    console.log('Response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Graph data loaded:', data);

                    // Initialize cytoscape
                    const cy = cytoscape({
                        container: document.getElementById('cy'),
                        elements: data,
                        style: [
                            {
                                selector: 'node',
                                style: {
                                    'label': 'data(label)',
                                    'text-valign': 'center',
                                    'text-halign': 'center',
                                    'background-color': '#6FB1FC',
                                    'text-outline-width': 2,
                                    'text-outline-color': body.classList.contains('dark-mode') ? '#333' : '#fff',
                                    'color': body.classList.contains('dark-mode') ? '#fff' : '#000'
                                }
                            },
                            {
                                selector: 'edge',
                                style: {
                                    'width': 2,
                                    'line-color': body.classList.contains('dark-mode') ? '#888' : '#ccc',
                                    'target-arrow-color': body.classList.contains('dark-mode') ? '#888' : '#ccc',
                                    'target-arrow-shape': 'triangle',
                                    'curve-style': 'bezier'
                                }
                            },
                            {
                                selector: '.highlighted',
                                style: {
                                    'background-color': '#ff7f0e',
                                    'line-color': '#ff7f0e',
                                    'target-arrow-color': '#ff7f0e',
                                    'transition-property': 'background-color, line-color, target-arrow-color',
                                    'transition-duration': '0.5s'
                                }
                            },
                            {
                                selector: '.reachable',
                                style: {
                                    'background-color': '#2ca02c',
                                    'line-color': '#2ca02c',
                                    'target-arrow-color': '#2ca02c',
                                    'transition-property': 'background-color, line-color, target-arrow-color',
                                    'transition-duration': '0.5s'
                                }
                            },
                            {
                                selector: '.prerequisite',
                                style: {
                                    'background-color': '#d62728',
                                    'line-color': '#d62728',
                                    'target-arrow-color': '#d62728',
                                    'transition-property': 'background-color, line-color, target-arrow-color',
                                    'transition-duration': '0.5s'
                                }
                            },
                            {
                                selector: '.faded',
                                style: {
                                    'opacity': 0.25,
                                    'transition-property': 'opacity',
                                    'transition-duration': '0.5s'
                                }
                            },
                            {
                                selector: '.hidden',
                                style: {
                                    'display': 'none'
                                }
                            }
                        ],
                        layout: {
                            name: 'circle', // Start with a simple layout
                            padding: 30
                        }
                    });

                    // Make cy available globally for the layout selector
                    window.cy = cy;

                    // Function to apply selected layout
                    function applyLayout(layoutName) {
                        console.log(`Applying layout: ${layoutName}`);

                        let layoutOptions = {
                            name: layoutName,
                            padding: 30,
                            animate: true,
                            fit: true
                        };

                        // Add specific options for certain layouts
                        if (layoutName === 'dagre') {
                            // Check if dagre layout is available
                            if (typeof cytoscapeDagre === 'undefined') {
                                console.error('Dagre layout is not available!');
                                // Fall back to breadthfirst layout
                                layoutName = 'breadthfirst';
                                layoutOptions = {
                                    name: 'breadthfirst',
                                    directed: true,
                                    padding: 30,
                                    spacingFactor: 1.5,
                                    animate: true,
                                    fit: true
                                };
                            } else {
                                layoutOptions = {
                                    name: 'dagre',
                                    rankDir: 'TB',
                                    nodeSep: 80,
                                    rankSep: 120,
                                    padding: 30,
                                    fit: true,
                                    animate: true,
                                    animationDuration: 500,
                                    // Optimize for edge crossings
                                    edgeWeight: edge => 1,
                                    // Increase iterations for better layout
                                    maxIterations: 2000
                                };
                            }
                        } else if (layoutName === 'breadthfirst') {
                            layoutOptions.spacingFactor = 1.8;
                            layoutOptions.circle = false;
                            layoutOptions.grid = true;
                            layoutOptions.directed = true;
                            layoutOptions.avoidOverlap = true;
                            layoutOptions.roots = cy.nodes().roots();
                        } else if (layoutName === 'concentric') {
                            layoutOptions.minNodeSpacing = 80;
                            layoutOptions.avoidOverlap = true;
                            layoutOptions.startAngle = 3 / 2 * Math.PI; // Start from top
                            layoutOptions.sweep = 2 * Math.PI; // Full 360 degrees
                            layoutOptions.equidistant = true; // Equal distance between levels
                            // Use node degree for concentric layout ordering
                            layoutOptions.concentric = function(node) {
                                return node.indegree();
                            };
                        } else if (layoutName === 'cose') {
                            layoutOptions.idealEdgeLength = 150;
                            layoutOptions.nodeOverlap = 20;
                            layoutOptions.refresh = 20;
                            layoutOptions.fit = true;
                            layoutOptions.padding = 30;
                            layoutOptions.randomize = false;
                            layoutOptions.componentSpacing = 100;
                            layoutOptions.nodeRepulsion = 4500;
                            layoutOptions.edgeElasticity = 100;
                            layoutOptions.nestingFactor = 1.2;
                            layoutOptions.gravity = 80;
                            layoutOptions.numIter = 1000;
                            layoutOptions.initialTemp = 200;
                            layoutOptions.coolingFactor = 0.95;
                            layoutOptions.minTemp = 1.0;
                        } else if (layoutName === 'circle') {
                            layoutOptions.avoidOverlap = true;
                            layoutOptions.radius = 250;
                            layoutOptions.startAngle = 3 / 2 * Math.PI; // Start from top
                            layoutOptions.sweep = 2 * Math.PI; // Full 360 degrees
                        }
                        
                        try {
                            console.log(`Creating layout with options:`, layoutOptions);
                            const layout = cy.layout(layoutOptions);
                            layout.run();
                            console.log(`Layout ${layoutName} applied successfully`);
                        } catch (error) {
                            console.error(`Error applying layout ${layoutName}:`, error);
                            // Fall back to circle layout
                            try {
                                cy.layout({ 
                                    name: 'circle', 
                                    padding: 30,
                                    avoidOverlap: true
                                }).run();
                                console.log('Fallback to circle layout applied');
                            } catch (fallbackError) {
                                console.error('Error applying fallback layout:', fallbackError);
                            }
                        }
                    }

                    // Add search functionality
                    // Add problem search functionality
                    const problemSearchInput = document.getElementById('problem-search');
                    const problemAutocompleteList = document.getElementById('problem-autocomplete-list');

                    // Function to update problem autocomplete list
                    function updateProblemAutocompleteList(query) {
                        // Clear previous autocomplete list
                        problemAutocompleteList.innerHTML = '';

                        if (!query || query.length < 1) {
                            // If empty query, show all problems (limited to first 20)
                            const allProblems = problemLabels.slice(0, 20);

                            if (allProblems.length > 0) {
                                problemAutocompleteList.style.display = 'block';

                                allProblems.forEach(problem => {
                                    const div = document.createElement('div');
                                    div.textContent = problem;
                                    div.addEventListener('click', function() {
                                        problemSearchInput.value = problem;
                                        problemAutocompleteList.style.display = 'none';
                                        // Clear the concept search input when selecting a problem
                                        searchInput.value = '';
                                        autocompleteList.style.display = 'none';
                                        highlightMatchingNodes(problem);
                                    });
                                    problemAutocompleteList.appendChild(div);
                                });
                            }
                        } else {
                            // Filter problems that match the query
                            const matches = problemLabels.filter(label =>
                                label.toLowerCase().includes(query.toLowerCase())
                            );

                            if (matches.length > 0) {
                                problemAutocompleteList.style.display = 'block';

                                // Sort matches by relevance (exact match first, then starts with, then includes)
                                matches.sort((a, b) => {
                                    const aLower = a.toLowerCase();
                                    const bLower = b.toLowerCase();
                                    const queryLower = query.toLowerCase();

                                    if (aLower === queryLower) return -1;
                                    if (bLower === queryLower) return 1;
                                    if (aLower.startsWith(queryLower) && !bLower.startsWith(queryLower)) return -1;
                                    if (bLower.startsWith(queryLower) && !aLower.startsWith(queryLower)) return 1;
                                    return a.localeCompare(b);
                                });

                                // Limit to 20 suggestions
                                const limitedMatches = matches.slice(0, 20);

                                // Create suggestion items
                                limitedMatches.forEach(match => {
                                    const div = document.createElement('div');
                                    div.textContent = match;
                                    div.addEventListener('click', function() {
                                        problemSearchInput.value = match;
                                        problemAutocompleteList.style.display = 'none';
                                        // Clear the concept search input when selecting a problem
                                        searchInput.value = '';
                                        autocompleteList.style.display = 'none';
                                        highlightMatchingNodes(match);
                                    });
                                    problemAutocompleteList.appendChild(div);
                                });
                            } else {
                                problemAutocompleteList.style.display = 'none';
                            }
                        }
                    }

                    // Show problem autocomplete dropdown when input is focused
                    problemSearchInput.addEventListener('focus', function() {
                        updateProblemAutocompleteList(this.value);
                    });

                    // Update problem autocomplete list as user types
                    problemSearchInput.addEventListener('input', function() {
                        const query = this.value;
                        // Clear the concept search input when typing in problem search
                        if (query.trim() !== '' && searchInput.value.trim() !== '') {
                            searchInput.value = '';
                            autocompleteList.style.display = 'none';
                        }
                        updateProblemAutocompleteList(query);

                        // Also highlight matching nodes as user types
                        highlightMatchingNodes(query);
                    });

                    // Hide problem autocomplete list when clicking outside
                    document.addEventListener('click', function(e) {
                        if (e.target !== problemSearchInput && !problemAutocompleteList.contains(e.target)) {
                            problemAutocompleteList.style.display = 'none';
                        }
                    });

                    // Keyboard navigation for problem autocomplete
                    problemSearchInput.addEventListener('keydown', function(e) {
                        const items = problemAutocompleteList.getElementsByTagName('div');
                        if (items.length === 0) return;

                        let activeItem = problemAutocompleteList.querySelector('.autocomplete-active');
                        const activeIndex = Array.from(items).indexOf(activeItem);

                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            if (activeItem) {
                                activeItem.classList.remove('autocomplete-active');
                                const nextIndex = (activeIndex + 1) % items.length;
                                items[nextIndex].classList.add('autocomplete-active');
                                items[nextIndex].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                problemSearchInput.value = items[nextIndex].textContent;
                                // Clear the concept search input
                                searchInput.value = '';
                                autocompleteList.style.display = 'none';
                                highlightMatchingNodes(items[nextIndex].textContent);
                            } else {
                                items[0].classList.add('autocomplete-active');
                                items[0].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                problemSearchInput.value = items[0].textContent;
                                // Clear the concept search input
                                searchInput.value = '';
                                autocompleteList.style.display = 'none';
                                highlightMatchingNodes(items[0].textContent);
                            }
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            if (activeItem) {
                                activeItem.classList.remove('autocomplete-active');
                                const prevIndex = (activeIndex - 1 + items.length) % items.length;
                                items[prevIndex].classList.add('autocomplete-active');
                                items[prevIndex].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                problemSearchInput.value = items[prevIndex].textContent;
                                // Clear the concept search input
                                searchInput.value = '';
                                autocompleteList.style.display = 'none';
                                highlightMatchingNodes(items[prevIndex].textContent);
                            } else {
                                items[items.length - 1].classList.add('autocomplete-active');
                                items[items.length - 1].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                problemSearchInput.value = items[items.length - 1].textContent;
                                // Clear the concept search input
                                searchInput.value = '';
                                autocompleteList.style.display = 'none';
                                highlightMatchingNodes(items[items.length - 1].textContent);
                            }
                        } else if (e.key === 'Enter') {
                            e.preventDefault();
                            if (activeItem) {
                                problemSearchInput.value = activeItem.textContent;
                                problemAutocompleteList.style.display = 'none';
                                // Clear the concept search input
                                searchInput.value = '';
                                autocompleteList.style.display = 'none';
                                highlightMatchingNodes(activeItem.textContent);
                            }
                        }
                    });

                    
                    const searchInput = document.getElementById('search');
                    const autocompleteList = document.getElementById('autocomplete-list');

                    // Get all concept labels for autocomplete (only nodes with type 'concept')
                    const conceptLabels = cy.nodes().filter(node => node.data('type') === 'concept').map(node => node.data('label'));
                    // Sort concept labels alphabetically for easier browsing
                    conceptLabels.sort((a, b) => a.localeCompare(b));                    // Get all concept labels for autocomplete (only nodes with type 'concept')
                    const problemLabels = cy.nodes().filter(node => node.data('type') === 'problem').map(node => node.data('label'));
                    // Sort concept labels alphabetically for easier browsing
                    problemLabels.sort((a, b) => a.localeCompare(b));



                    // Autocomplete functionality
                    function highlightMatchingNodes(query) {
                        // Reset all styles
                        resetStyles();
                        
                        if (query.length < 2) return;
                        
                        // Find matching nodes
                        const matchingNodes = cy.nodes().filter(node => {
                            return node.data('label').toLowerCase().includes(query.toLowerCase());
                        });
                        
                        if (matchingNodes.length > 0) {
                            // Apply the appropriate highlight based on the selected mode
                            const highlightMode = document.querySelector('input[name="highlight-mode"]:checked').value;
                            
                            if (matchingNodes.length === 1) {
                                // If only one node matches, apply the selected highlight mode
                                applyHighlightMode(matchingNodes[0], highlightMode);
                                
                                // Center on the selected node
                                cy.animate({
                                    center: { eles: matchingNodes },
                                    zoom: 1.5,
                                    duration: 500
                                });
                            } else {
                                // If multiple nodes match, just highlight them directly
                                matchingNodes.addClass('highlighted');
                                
                                // Hide all other nodes
                                cy.nodes().difference(matchingNodes).addClass('hidden');
                                cy.edges().addClass('hidden');
                            }
                            
                            // Rearrange the graph to focus only on visible nodes
                            rearrangeVisibleNodes();
                        }
                    }
                    
                    // Function to rearrange the graph to focus only on visible nodes
                    function rearrangeVisibleNodes() {
                        // Get all visible nodes
                        const visibleNodes = cy.nodes().filter(node => !node.hasClass('hidden'));
                        const visibleEdges = cy.edges().filter(edge => 
                            !edge.hasClass('hidden') && 
                            !edge.source().hasClass('hidden') && 
                            !edge.target().hasClass('hidden')
                        );
                        
                        if (visibleNodes.length > 0) {
                            // Create a new layout with only visible nodes
                            const layoutName = document.getElementById('layout-select').value;
                            
                            let layoutOptions = {
                                name: layoutName,
                                padding: 50,
                                animate: true,
                                fit: true,
                                // Only include visible elements in the layout
                                eles: visibleNodes.union(visibleEdges)
                            };
                            
                            // Add specific options for certain layouts
                            if (layoutName === 'dagre') {
                                if (typeof cytoscapeDagre !== 'undefined') {
                                    layoutOptions = {
                                        name: 'dagre',
                                        rankDir: 'TB',
                                        nodeSep: 80,
                                        rankSep: 120,
                                        padding: 50,
                                        fit: true,
                                        animate: true,
                                        animationDuration: 500,
                                        eles: visibleNodes.union(visibleEdges),
                                        // Optimize for edge crossings
                                        edgeWeight: edge => 1,
                                        // Increase iterations for better layout
                                        maxIterations: 2000
                                    };
                                } else {
                                    layoutOptions = {
                                        name: 'breadthfirst',
                                        directed: true,
                                        padding: 50,
                                        spacingFactor: 1.8,
                                        animate: true,
                                        fit: true,
                                        eles: visibleNodes.union(visibleEdges),
                                        avoidOverlap: true
                                    };
                                }
                            } else if (layoutName === 'breadthfirst') {
                                layoutOptions.spacingFactor = 1.8;
                                layoutOptions.circle = false;
                                layoutOptions.grid = true;
                                layoutOptions.directed = true;
                                layoutOptions.avoidOverlap = true;
                                
                                // Try to find root nodes (nodes with no incoming edges)
                                const roots = visibleNodes.filter(node => 
                                    node.incomers('edge').filter(e => !e.hasClass('hidden')).size() === 0
                                );
                                
                                if (roots.length > 0) {
                                    layoutOptions.roots = roots;
                                }
                            } else if (layoutName === 'concentric') {
                                layoutOptions.minNodeSpacing = 80;
                                layoutOptions.avoidOverlap = true;
                                layoutOptions.startAngle = 3 / 2 * Math.PI; // Start from top
                                layoutOptions.sweep = 2 * Math.PI; // Full 360 degrees
                                layoutOptions.equidistant = true; // Equal distance between levels
                                // Use node degree for concentric layout ordering
                                layoutOptions.concentric = function(node) {
                                    return node.indegree();
                                };
                            } else if (layoutName === 'cose') {
                                layoutOptions.idealEdgeLength = 100;
                                layoutOptions.nodeOverlap = 10;
                                layoutOptions.refresh = 20;
                                layoutOptions.fit = true;
                                layoutOptions.padding = 30;
                                layoutOptions.randomize = false;
                                layoutOptions.componentSpacing = 60;
                                layoutOptions.nodeRepulsion = 2500;
                                layoutOptions.edgeElasticity = 100;
                                layoutOptions.nestingFactor = 1.0;
                                layoutOptions.gravity = 50;
                                layoutOptions.numIter = 1000;
                                layoutOptions.initialTemp = 200;
                                layoutOptions.coolingFactor = 0.95;
                                layoutOptions.minTemp = 1.0;
                            } else if (layoutName === 'circle') {
                                layoutOptions.avoidOverlap = true;
                                layoutOptions.radius = Math.max(150, visibleNodes.length * 10);
                                layoutOptions.startAngle = 3 / 2 * Math.PI; // Start from top
                                layoutOptions.sweep = 2 * Math.PI; // Full 360 degrees
                            }
                            
                            try {
                                console.log(`Rearranging visible nodes with layout: ${layoutName}`);
                                const layout = cy.layout(layoutOptions);
                                layout.run();
                                
                                // Fit the view to show all visible nodes
                                setTimeout(() => {
                                    cy.fit(visibleNodes, 50);
                                }, 600);
                            } catch (error) {
                                console.error(`Error rearranging visible nodes:`, error);
                                // Fall back to circle layout
                                try {
                                    cy.layout({ 
                                        name: 'circle', 
                                        padding: 50,
                                        eles: visibleNodes,
                                        avoidOverlap: true,
                                        radius: Math.max(150, visibleNodes.length * 10)
                                    }).run();
                                    
                                    // Fit the view to show all visible nodes
                                    setTimeout(() => {
                                        cy.fit(visibleNodes, 50);
                                    }, 600);
                                } catch (fallbackError) {
                                    console.error('Error applying fallback layout:', fallbackError);
                                }
                            }
                        }
                    }
                    
                    // Function to focus on a specific node by ID
                    function focusOnNode(nodeId) {
                        const node = cy.getElementById(nodeId);
                        if (node.length > 0) {
                            // Reset all styles
                            resetStyles();
                            
                            // Apply the appropriate highlight based on the selected mode
                            const highlightMode = document.querySelector('input[name="highlight-mode"]:checked').value;
                            applyHighlightMode(node, highlightMode);
                            
                            // Center on the node
                            cy.animate({
                                center: { eles: node },
                                zoom: 1.5,
                                duration: 500
                            });
                            
                            // Update search input with the node's label
                            searchInput.value = node.data('label');
                            
                            // Rearrange the graph to focus only on visible nodes
                            rearrangeVisibleNodes();
                            
                            console.log(`Focused on node: ${nodeId} (${node.data('label')})`);
                            return true;
                        } else {
                            console.error(`Node not found: ${nodeId}`);
                            return false;
                        }
                    }
                    
                    // Function to reset all styles
                    function resetStyles() {
                        cy.elements().removeClass('highlighted reachable prerequisite faded hidden');
                    }
                    
                    // Function to apply the selected highlight mode
                    function applyHighlightMode(node, mode) {
                        if (mode === 'direct') {
                            // Highlight the node and its direct connections
                            node.addClass('highlighted');
                            const connectedEdges = node.connectedEdges();
                            connectedEdges.addClass('highlighted');
                            const connectedNodes = connectedEdges.connectedNodes();
                            
                            // Hide all other nodes and edges
                            cy.nodes().difference(node).difference(connectedNodes).addClass('hidden');
                            cy.edges().difference(connectedEdges).addClass('hidden');
                        } 
                        else if (mode === 'reachable') {
                            // Highlight the node
                            node.addClass('highlighted');
                            
                            // Find all nodes reachable from this node (BFS)
                            const reachableNodes = [];
                            const reachableEdges = [];
                            
                            // Start BFS from the selected node
                            const queue = [node];
                            const visited = new Set([node.id()]);
                            
                            while (queue.length > 0) {
                                const currentNode = queue.shift();
                                
                                // Get outgoing edges
                                const outgoingEdges = currentNode.outgoers('edge');
                                outgoingEdges.forEach(edge => {
                                    reachableEdges.push(edge);
                                    
                                    const targetNode = edge.target();
                                    if (!visited.has(targetNode.id())) {
                                        visited.add(targetNode.id());
                                        reachableNodes.push(targetNode);
                                        queue.push(targetNode);
                                    }
                                });
                            }
                            
                            // Highlight reachable nodes and edges
                            cy.collection(reachableNodes).addClass('reachable');
                            cy.collection(reachableEdges).addClass('reachable');
                            
                            // Hide all other nodes and edges
                            cy.nodes().difference(node).difference(cy.collection(reachableNodes)).addClass('hidden');
                            cy.edges().difference(cy.collection(reachableEdges)).addClass('hidden');
                        }
                        else if (mode === 'prerequisites') {
                            // Highlight the node
                            node.addClass('highlighted');
                            
                            // Find all prerequisite nodes (reverse BFS)
                            const prerequisiteNodes = [];
                            const prerequisiteEdges = [];
                            
                            // Start reverse BFS from the selected node
                            const queue = [node];
                            const visited = new Set([node.id()]);
                            
                            while (queue.length > 0) {
                                const currentNode = queue.shift();
                                
                                // Get incoming edges
                                const incomingEdges = currentNode.incomers('edge');
                                incomingEdges.forEach(edge => {
                                    prerequisiteEdges.push(edge);
                                    
                                    const sourceNode = edge.source();
                                    if (!visited.has(sourceNode.id())) {
                                        visited.add(sourceNode.id());
                                        prerequisiteNodes.push(sourceNode);
                                        queue.push(sourceNode);
                                    }
                                });
                            }
                            
                            // Highlight prerequisite nodes and edges
                            cy.collection(prerequisiteNodes).addClass('prerequisite');
                            cy.collection(prerequisiteEdges).addClass('prerequisite');
                            
                            // Hide all other nodes and edges
                            cy.nodes().difference(node).difference(cy.collection(prerequisiteNodes)).addClass('hidden');
                            cy.edges().difference(cy.collection(prerequisiteEdges)).addClass('hidden');
                        }
                    }
                    
                    // Function to update autocomplete list
                    function updateAutocompleteList(query) {
                        // Clear previous autocomplete list
                        autocompleteList.innerHTML = '';

                        if (!query || query.length < 1) {
                            // If empty query, show all concepts (limited to first 20)
                            const allConcepts = conceptLabels.slice(0, 20);

                            if (allConcepts.length > 0) {
                                autocompleteList.style.display = 'block';

                                allConcepts.forEach(concept => {
                                    const div = document.createElement('div');
                                    div.textContent = concept;
                                    div.addEventListener('click', function() {
                                        searchInput.value = concept;
                                        autocompleteList.style.display = 'none';
                                        // Clear the problem search input when selecting a concept
                                        problemSearchInput.value = '';
                                        problemAutocompleteList.style.display = 'none';
                                        highlightMatchingNodes(concept);
                                    });
                                    autocompleteList.appendChild(div);
                                });
                            }
                        } else {
                            // Filter concepts that match the query
                            const matches = conceptLabels.filter(label =>
                                label.toLowerCase().includes(query.toLowerCase())
                            );

                            if (matches.length > 0) {
                                autocompleteList.style.display = 'block';

                                // Sort matches by relevance (exact match first, then starts with, then includes)
                                matches.sort((a, b) => {
                                    const aLower = a.toLowerCase();
                                    const bLower = b.toLowerCase();
                                    const queryLower = query.toLowerCase();

                                    if (aLower === queryLower) return -1;
                                    if (bLower === queryLower) return 1;
                                    if (aLower.startsWith(queryLower) && !bLower.startsWith(queryLower)) return -1;
                                    if (bLower.startsWith(queryLower) && !aLower.startsWith(queryLower)) return 1;
                                    return a.localeCompare(b);
                                });

                                // Limit to 20 suggestions
                                const limitedMatches = matches.slice(0, 20);

                                // Create suggestion items
                                limitedMatches.forEach(match => {
                                    const div = document.createElement('div');
                                    div.textContent = match;
                                    div.addEventListener('click', function() {
                                        searchInput.value = match;
                                        autocompleteList.style.display = 'none';
                                        highlightMatchingNodes(match);
                                    });
                                    autocompleteList.appendChild(div);
                                });
                            } else {
                                autocompleteList.style.display = 'none';
                            }
                        }
                    }

                    // Show autocomplete dropdown when input is focused
                    searchInput.addEventListener('focus', function() {
                        updateAutocompleteList(this.value);
                    });

                    // Update autocomplete list as user types
                    searchInput.addEventListener('input', function() {
                        const query = this.value;
                        updateAutocompleteList(query);

                        // Also highlight matching nodes as user types
                        highlightMatchingNodes(query);
                    });

                    // Hide autocomplete list when clicking outside
                    document.addEventListener('click', function(e) {
                        if (e.target !== searchInput && !autocompleteList.contains(e.target)) {
                            autocompleteList.style.display = 'none';
                        }
                    });

                    // Keyboard navigation for autocomplete
                    searchInput.addEventListener('keydown', function(e) {
                        const items = autocompleteList.getElementsByTagName('div');
                        if (items.length === 0) return;

                        let activeItem = autocompleteList.querySelector('.autocomplete-active');
                        const activeIndex = Array.from(items).indexOf(activeItem);

                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            if (activeItem) {
                                activeItem.classList.remove('autocomplete-active');
                                const nextIndex = (activeIndex + 1) % items.length;
                                items[nextIndex].classList.add('autocomplete-active');
                                items[nextIndex].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                searchInput.value = items[nextIndex].textContent;
                                highlightMatchingNodes(items[nextIndex].textContent);
                            } else {
                                items[0].classList.add('autocomplete-active');
                                items[0].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                searchInput.value = items[0].textContent;
                                highlightMatchingNodes(items[0].textContent);
                            }
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            if (activeItem) {
                                activeItem.classList.remove('autocomplete-active');
                                const prevIndex = (activeIndex - 1 + items.length) % items.length;
                                items[prevIndex].classList.add('autocomplete-active');
                                items[prevIndex].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                searchInput.value = items[prevIndex].textContent;
                                highlightMatchingNodes(items[prevIndex].textContent);
                            } else {
                                items[items.length - 1].classList.add('autocomplete-active');
                                items[items.length - 1].scrollIntoView({ block: 'nearest' });
                                
                                // Update search input and highlight in real-time
                                searchInput.value = items[items.length - 1].textContent;
                                highlightMatchingNodes(items[items.length - 1].textContent);
                            }
                        } else if (e.key === 'Enter') {
                            e.preventDefault();
                            if (activeItem) {
                                searchInput.value = activeItem.textContent;
                                autocompleteList.style.display = 'none';
                                highlightMatchingNodes(activeItem.textContent);
                            } else if (items.length > 0) {
                                // If no active item but there are items, select the first one
                                searchInput.value = items[0].textContent;
                                autocompleteList.style.display = 'none';
                                highlightMatchingNodes(items[0].textContent);
                            }
                        } else if (e.key === 'Escape') {
                            autocompleteList.style.display = 'none';
                        }
                    });

                    // Layout selection change event
                    const layoutSelect = document.getElementById('layout-select');
                    layoutSelect.addEventListener('change', function() {
                        applyLayout(this.value);
                    });

                    // Reset button
                    document.getElementById('reset').addEventListener('click', function() {
                        resetStyles();
                        searchInput.value = '';
                        autocompleteList.style.display = 'none';
                        cy.fit();

                        // Apply circle layout
                        layoutSelect.value = 'circle';
                        applyLayout('circle');
                    });

                    // Double-click to focus on a node
                    cy.on('dblclick', 'node', function(evt) {
                        const node = evt.target;
                        resetStyles();
                        
                        // Apply the appropriate highlight based on the selected mode
                        const highlightMode = document.querySelector('input[name="highlight-mode"]:checked').value;
                        applyHighlightMode(node, highlightMode);

                        // Center on the selected node
                        cy.animate({
                            center: { eles: node },
                            zoom: 1.5,
                            duration: 500
                        });

                        // Update search input with the selected node's label
                        searchInput.value = node.data('label');
                        
                        // Rearrange the graph to focus only on visible nodes
                        rearrangeVisibleNodes();
                    });
                    
                    // Add event listener for highlight mode change
                    document.querySelectorAll('input[name="highlight-mode"]').forEach(radio => {
                        radio.addEventListener('change', function() {
                            // If a node is currently selected (search input has a value), reapply highlight
                            if (searchInput.value.trim() !== '') {
                                highlightMatchingNodes(searchInput.value);
                            }
                        });
                    });

                    // Apply circle layout first, then focus on algorithm_design
                    setTimeout(() => {
                        try {
                            applyLayout('circle');
                            console.log('Initial circle layout applied');

                            // After layout is applied, focus on algorithm_design
                            setTimeout(() => {
                                // Find the algorithm_design node
                                const algorithmDesignNode = cy.nodes().filter(node =>
                                    node.data('id') === 'algorithm_design'
                                );

                                if (algorithmDesignNode.length > 0) {
                                    // Apply the appropriate highlight based on the selected mode
                                    const highlightMode = document.querySelector('input[name="highlight-mode"]:checked').value;
                                    applyHighlightMode(algorithmDesignNode[0], highlightMode);

                                    // Center on the node
                                    cy.animate({
                                        center: { eles: algorithmDesignNode },
                                        zoom: 1.5,
                                        duration: 500
                                    });

                                    // Update search input
                                    searchInput.value = algorithmDesignNode.data('label');

                                    console.log('Focused on algorithm_design node');
                                } else {
                                    console.error('algorithm_design node not found');
                                }
                            }, 1000);
                        } catch (error) {
                            console.error('Error applying initial layout:', error);
                        }
                    }, 500);
                })
                .catch(error => {
                    console.error('Error loading graph data:', error);
                });
        };
    </script>
</body>
</html>
